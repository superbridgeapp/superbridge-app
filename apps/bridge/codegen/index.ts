/**
 * Generated by orval v6.10.3 üç∫
 * Do not edit manually.
 * API
 * API docs
 * OpenAPI spec version: 1.0
 */
import axios from 'axios'
import type {
  AxiosRequestConfig,
  AxiosResponse,
  AxiosError
} from 'axios'
import {
  useQuery,
  useMutation
} from '@tanstack/react-query'
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey
} from '@tanstack/react-query'
import type {
  ActivityDto,
  BridgeControllerGetActivityParams,
  GetActivityDto,
  TransactionDto,
  IdDto,
  FiatPricesDto,
  PricesDto,
  DeploymentDto,
  BridgeControllerGetDeploymentsParams,
  DeploymentsQueryDto,
  CctpDomainDto,
  SyncStatusDto,
  CcipReadResponseDto,
  CcipReadDto,
  ConduitDeploymentConfigDto,
  CreateConduitDeploymentDto,
  ActionDto,
  BridgeNftDto,
  BoolDto
} from './model'


type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


export const bridgeControllerGetActivity = (
    address: string,
    params: BridgeControllerGetActivityParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ActivityDto>> => {
    return axios.get(
      `/api/bridge/activity/${address}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getBridgeControllerGetActivityQueryKey = (address: string,
    params: BridgeControllerGetActivityParams,) => [`/api/bridge/activity/${address}`, ...(params ? [params]: [])];

    
export type BridgeControllerGetActivityQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetActivity>>>
export type BridgeControllerGetActivityQueryError = AxiosError<unknown>

export const useBridgeControllerGetActivity = <TData = Awaited<ReturnType<typeof bridgeControllerGetActivity>>, TError = AxiosError<unknown>>(
 address: string,
    params: BridgeControllerGetActivityParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetActivity>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBridgeControllerGetActivityQueryKey(address,params);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetActivity>>> = ({ signal }) => bridgeControllerGetActivity(address,params, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof bridgeControllerGetActivity>>, TError, TData>(queryKey, queryFn, {enabled: !!(address), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


export const bridgeControllerGetActivityV2 = (
    getActivityDto: GetActivityDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ActivityDto>> => {
    return axios.post(
      `/api/bridge/activity`,
      getActivityDto,options
    );
  }



    export type BridgeControllerGetActivityV2MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetActivityV2>>>
    export type BridgeControllerGetActivityV2MutationBody = GetActivityDto
    export type BridgeControllerGetActivityV2MutationError = AxiosError<unknown>

    export const useBridgeControllerGetActivityV2 = <TError = AxiosError<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetActivityV2>>, TError,{data: GetActivityDto}, TContext>, axios?: AxiosRequestConfig}
) => {
      const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetActivityV2>>, {data: GetActivityDto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerGetActivityV2(data,axiosOptions)
        }

      return useMutation<Awaited<ReturnType<typeof bridgeControllerGetActivityV2>>, TError, {data: GetActivityDto}, TContext>(mutationFn, mutationOptions)
    }
    
export const bridgeControllerGetProveTransactionV2 = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionDto>> => {
    return axios.get(
      `/api/bridge/prove_transaction_v2/${id}`,options
    );
  }


export const getBridgeControllerGetProveTransactionV2QueryKey = (id: string,) => [`/api/bridge/prove_transaction_v2/${id}`];

    
export type BridgeControllerGetProveTransactionV2QueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetProveTransactionV2>>>
export type BridgeControllerGetProveTransactionV2QueryError = AxiosError<unknown>

export const useBridgeControllerGetProveTransactionV2 = <TData = Awaited<ReturnType<typeof bridgeControllerGetProveTransactionV2>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetProveTransactionV2>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBridgeControllerGetProveTransactionV2QueryKey(id);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetProveTransactionV2>>> = ({ signal }) => bridgeControllerGetProveTransactionV2(id, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof bridgeControllerGetProveTransactionV2>>, TError, TData>(queryKey, queryFn, {enabled: !!(id), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


export const bridgeControllerGetProveTransaction = (
    idDto: IdDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionDto>> => {
    return axios.post(
      `/api/bridge/op_prove`,
      idDto,options
    );
  }



    export type BridgeControllerGetProveTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetProveTransaction>>>
    export type BridgeControllerGetProveTransactionMutationBody = IdDto
    export type BridgeControllerGetProveTransactionMutationError = AxiosError<unknown>

    export const useBridgeControllerGetProveTransaction = <TError = AxiosError<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetProveTransaction>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
) => {
      const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetProveTransaction>>, {data: IdDto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerGetProveTransaction(data,axiosOptions)
        }

      return useMutation<Awaited<ReturnType<typeof bridgeControllerGetProveTransaction>>, TError, {data: IdDto}, TContext>(mutationFn, mutationOptions)
    }
    
export const bridgeControllerGetFinaliseTransactionV2 = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionDto>> => {
    return axios.get(
      `/api/bridge/finalise_transaction_v2/${id}`,options
    );
  }


export const getBridgeControllerGetFinaliseTransactionV2QueryKey = (id: string,) => [`/api/bridge/finalise_transaction_v2/${id}`];

    
export type BridgeControllerGetFinaliseTransactionV2QueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransactionV2>>>
export type BridgeControllerGetFinaliseTransactionV2QueryError = AxiosError<unknown>

export const useBridgeControllerGetFinaliseTransactionV2 = <TData = Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransactionV2>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransactionV2>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBridgeControllerGetFinaliseTransactionV2QueryKey(id);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransactionV2>>> = ({ signal }) => bridgeControllerGetFinaliseTransactionV2(id, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransactionV2>>, TError, TData>(queryKey, queryFn, {enabled: !!(id), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


export const bridgeControllerGetFinaliseTransaction = (
    idDto: IdDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionDto>> => {
    return axios.post(
      `/api/bridge/op_finalise`,
      idDto,options
    );
  }



    export type BridgeControllerGetFinaliseTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransaction>>>
    export type BridgeControllerGetFinaliseTransactionMutationBody = IdDto
    export type BridgeControllerGetFinaliseTransactionMutationError = AxiosError<unknown>

    export const useBridgeControllerGetFinaliseTransaction = <TError = AxiosError<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransaction>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
) => {
      const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransaction>>, {data: IdDto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerGetFinaliseTransaction(data,axiosOptions)
        }

      return useMutation<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransaction>>, TError, {data: IdDto}, TContext>(mutationFn, mutationOptions)
    }
    
export const bridgeControllerGetArbitrumFinaliseTransaction = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionDto>> => {
    return axios.get(
      `/api/bridge/arbitrum_finalise_transaction/${id}`,options
    );
  }


export const getBridgeControllerGetArbitrumFinaliseTransactionQueryKey = (id: string,) => [`/api/bridge/arbitrum_finalise_transaction/${id}`];

    
export type BridgeControllerGetArbitrumFinaliseTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransaction>>>
export type BridgeControllerGetArbitrumFinaliseTransactionQueryError = AxiosError<unknown>

export const useBridgeControllerGetArbitrumFinaliseTransaction = <TData = Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransaction>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransaction>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBridgeControllerGetArbitrumFinaliseTransactionQueryKey(id);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransaction>>> = ({ signal }) => bridgeControllerGetArbitrumFinaliseTransaction(id, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransaction>>, TError, TData>(queryKey, queryFn, {enabled: !!(id), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


export const bridgeControllerGetArbitrumFinaliseTransactionV2 = (
    idDto: IdDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionDto>> => {
    return axios.post(
      `/api/bridge/arb_finalise`,
      idDto,options
    );
  }



    export type BridgeControllerGetArbitrumFinaliseTransactionV2MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransactionV2>>>
    export type BridgeControllerGetArbitrumFinaliseTransactionV2MutationBody = IdDto
    export type BridgeControllerGetArbitrumFinaliseTransactionV2MutationError = AxiosError<unknown>

    export const useBridgeControllerGetArbitrumFinaliseTransactionV2 = <TError = AxiosError<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransactionV2>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
) => {
      const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransactionV2>>, {data: IdDto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerGetArbitrumFinaliseTransactionV2(data,axiosOptions)
        }

      return useMutation<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransactionV2>>, TError, {data: IdDto}, TContext>(mutationFn, mutationOptions)
    }
    
export const bridgeControllerGetCctpMintTransaction = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionDto>> => {
    return axios.get(
      `/api/bridge/cctp_mint/${id}`,options
    );
  }


export const getBridgeControllerGetCctpMintTransactionQueryKey = (id: string,) => [`/api/bridge/cctp_mint/${id}`];

    
export type BridgeControllerGetCctpMintTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransaction>>>
export type BridgeControllerGetCctpMintTransactionQueryError = AxiosError<unknown>

export const useBridgeControllerGetCctpMintTransaction = <TData = Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransaction>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransaction>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBridgeControllerGetCctpMintTransactionQueryKey(id);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransaction>>> = ({ signal }) => bridgeControllerGetCctpMintTransaction(id, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransaction>>, TError, TData>(queryKey, queryFn, {enabled: !!(id), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


export const bridgeControllerGetCctpMintTransactionV2 = (
    idDto: IdDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionDto>> => {
    return axios.post(
      `/api/bridge/cctp_mint`,
      idDto,options
    );
  }



    export type BridgeControllerGetCctpMintTransactionV2MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransactionV2>>>
    export type BridgeControllerGetCctpMintTransactionV2MutationBody = IdDto
    export type BridgeControllerGetCctpMintTransactionV2MutationError = AxiosError<unknown>

    export const useBridgeControllerGetCctpMintTransactionV2 = <TError = AxiosError<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransactionV2>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
) => {
      const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransactionV2>>, {data: IdDto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerGetCctpMintTransactionV2(data,axiosOptions)
        }

      return useMutation<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransactionV2>>, TError, {data: IdDto}, TContext>(mutationFn, mutationOptions)
    }
    
export const bridgeControllerFiatPrices = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FiatPricesDto>> => {
    return axios.get(
      `/api/bridge/fiat_prices`,options
    );
  }


export const getBridgeControllerFiatPricesQueryKey = () => [`/api/bridge/fiat_prices`];

    
export type BridgeControllerFiatPricesQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerFiatPrices>>>
export type BridgeControllerFiatPricesQueryError = AxiosError<unknown>

export const useBridgeControllerFiatPrices = <TData = Awaited<ReturnType<typeof bridgeControllerFiatPrices>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerFiatPrices>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBridgeControllerFiatPricesQueryKey();

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerFiatPrices>>> = ({ signal }) => bridgeControllerFiatPrices({ signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof bridgeControllerFiatPrices>>, TError, TData>(queryKey, queryFn, queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


export const bridgeControllerGetTokenPrices = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PricesDto>> => {
    return axios.get(
      `/api/bridge/token_prices`,options
    );
  }


export const getBridgeControllerGetTokenPricesQueryKey = () => [`/api/bridge/token_prices`];

    
export type BridgeControllerGetTokenPricesQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>>
export type BridgeControllerGetTokenPricesQueryError = AxiosError<unknown>

export const useBridgeControllerGetTokenPrices = <TData = Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBridgeControllerGetTokenPricesQueryKey();

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>> = ({ signal }) => bridgeControllerGetTokenPrices({ signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>, TError, TData>(queryKey, queryFn, queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


export const bridgeControllerGetDeployments = (
    params?: BridgeControllerGetDeploymentsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DeploymentDto[]>> => {
    return axios.get(
      `/api/bridge/deployments`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getBridgeControllerGetDeploymentsQueryKey = (params?: BridgeControllerGetDeploymentsParams,) => [`/api/bridge/deployments`, ...(params ? [params]: [])];

    
export type BridgeControllerGetDeploymentsQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetDeployments>>>
export type BridgeControllerGetDeploymentsQueryError = AxiosError<unknown>

export const useBridgeControllerGetDeployments = <TData = Awaited<ReturnType<typeof bridgeControllerGetDeployments>>, TError = AxiosError<unknown>>(
 params?: BridgeControllerGetDeploymentsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeployments>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBridgeControllerGetDeploymentsQueryKey(params);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetDeployments>>> = ({ signal }) => bridgeControllerGetDeployments(params, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof bridgeControllerGetDeployments>>, TError, TData>(queryKey, queryFn, queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


export const bridgeControllerGetDeploymentsV2 = (
    deploymentsQueryDto: DeploymentsQueryDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DeploymentDto[]>> => {
    return axios.post(
      `/api/bridge/deployments`,
      deploymentsQueryDto,options
    );
  }



    export type BridgeControllerGetDeploymentsV2MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsV2>>>
    export type BridgeControllerGetDeploymentsV2MutationBody = DeploymentsQueryDto
    export type BridgeControllerGetDeploymentsV2MutationError = AxiosError<unknown>

    export const useBridgeControllerGetDeploymentsV2 = <TError = AxiosError<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsV2>>, TError,{data: DeploymentsQueryDto}, TContext>, axios?: AxiosRequestConfig}
) => {
      const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsV2>>, {data: DeploymentsQueryDto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerGetDeploymentsV2(data,axiosOptions)
        }

      return useMutation<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsV2>>, TError, {data: DeploymentsQueryDto}, TContext>(mutationFn, mutationOptions)
    }
    
export const bridgeControllerGetDeploymentsByDomain = (
    domain: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DeploymentDto[]>> => {
    return axios.get(
      `/api/bridge/deployments_by_domain/${domain}`,options
    );
  }


export const getBridgeControllerGetDeploymentsByDomainQueryKey = (domain: string,) => [`/api/bridge/deployments_by_domain/${domain}`];

    
export type BridgeControllerGetDeploymentsByDomainQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>>
export type BridgeControllerGetDeploymentsByDomainQueryError = AxiosError<unknown>

export const useBridgeControllerGetDeploymentsByDomain = <TData = Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>, TError = AxiosError<unknown>>(
 domain: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBridgeControllerGetDeploymentsByDomainQueryKey(domain);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>> = ({ signal }) => bridgeControllerGetDeploymentsByDomain(domain, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>, TError, TData>(queryKey, queryFn, {enabled: !!(domain), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


export const bridgeControllerGetCctpDomains = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CctpDomainDto[]>> => {
    return axios.get(
      `/api/bridge/cctp_domains`,options
    );
  }


export const getBridgeControllerGetCctpDomainsQueryKey = () => [`/api/bridge/cctp_domains`];

    
export type BridgeControllerGetCctpDomainsQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>>
export type BridgeControllerGetCctpDomainsQueryError = AxiosError<unknown>

export const useBridgeControllerGetCctpDomains = <TData = Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBridgeControllerGetCctpDomainsQueryKey();

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>> = ({ signal }) => bridgeControllerGetCctpDomains({ signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>, TError, TData>(queryKey, queryFn, queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


export const bridgeControllerGetDeploymentSyncStatus = (
    deploymentId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SyncStatusDto[]>> => {
    return axios.get(
      `/api/bridge/sync_status/${deploymentId}`,options
    );
  }


export const getBridgeControllerGetDeploymentSyncStatusQueryKey = (deploymentId: string,) => [`/api/bridge/sync_status/${deploymentId}`];

    
export type BridgeControllerGetDeploymentSyncStatusQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>>
export type BridgeControllerGetDeploymentSyncStatusQueryError = AxiosError<unknown>

export const useBridgeControllerGetDeploymentSyncStatus = <TData = Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>, TError = AxiosError<unknown>>(
 deploymentId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBridgeControllerGetDeploymentSyncStatusQueryKey(deploymentId);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>> = ({ signal }) => bridgeControllerGetDeploymentSyncStatus(deploymentId, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>, TError, TData>(queryKey, queryFn, {enabled: !!(deploymentId), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


export const bridgeControllerGetCctpSyncStatus = (
    chainId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SyncStatusDto[]>> => {
    return axios.get(
      `/api/bridge/cctp_sync_status/${chainId}`,options
    );
  }


export const getBridgeControllerGetCctpSyncStatusQueryKey = (chainId: string,) => [`/api/bridge/cctp_sync_status/${chainId}`];

    
export type BridgeControllerGetCctpSyncStatusQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetCctpSyncStatus>>>
export type BridgeControllerGetCctpSyncStatusQueryError = AxiosError<unknown>

export const useBridgeControllerGetCctpSyncStatus = <TData = Awaited<ReturnType<typeof bridgeControllerGetCctpSyncStatus>>, TError = AxiosError<unknown>>(
 chainId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpSyncStatus>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBridgeControllerGetCctpSyncStatusQueryKey(chainId);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetCctpSyncStatus>>> = ({ signal }) => bridgeControllerGetCctpSyncStatus(chainId, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof bridgeControllerGetCctpSyncStatus>>, TError, TData>(queryKey, queryFn, {enabled: !!(chainId), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


export const bridgeControllerHandleCctpHyperlane = (
    ccipReadDto: CcipReadDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CcipReadResponseDto[]>> => {
    return axios.post(
      `/api/bridge/cctp`,
      ccipReadDto,options
    );
  }



    export type BridgeControllerHandleCctpHyperlaneMutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerHandleCctpHyperlane>>>
    export type BridgeControllerHandleCctpHyperlaneMutationBody = CcipReadDto
    export type BridgeControllerHandleCctpHyperlaneMutationError = AxiosError<unknown>

    export const useBridgeControllerHandleCctpHyperlane = <TError = AxiosError<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerHandleCctpHyperlane>>, TError,{data: CcipReadDto}, TContext>, axios?: AxiosRequestConfig}
) => {
      const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerHandleCctpHyperlane>>, {data: CcipReadDto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerHandleCctpHyperlane(data,axiosOptions)
        }

      return useMutation<Awaited<ReturnType<typeof bridgeControllerHandleCctpHyperlane>>, TError, {data: CcipReadDto}, TContext>(mutationFn, mutationOptions)
    }
    
export const bridgeControllerCreateConduitDeployment = (
    createConduitDeploymentDto: CreateConduitDeploymentDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ConduitDeploymentConfigDto>> => {
    return axios.post(
      `/api/bridge/conduit/deployment`,
      createConduitDeploymentDto,options
    );
  }



    export type BridgeControllerCreateConduitDeploymentMutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerCreateConduitDeployment>>>
    export type BridgeControllerCreateConduitDeploymentMutationBody = CreateConduitDeploymentDto
    export type BridgeControllerCreateConduitDeploymentMutationError = AxiosError<unknown>

    export const useBridgeControllerCreateConduitDeployment = <TError = AxiosError<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerCreateConduitDeployment>>, TError,{data: CreateConduitDeploymentDto}, TContext>, axios?: AxiosRequestConfig}
) => {
      const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerCreateConduitDeployment>>, {data: CreateConduitDeploymentDto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerCreateConduitDeployment(data,axiosOptions)
        }

      return useMutation<Awaited<ReturnType<typeof bridgeControllerCreateConduitDeployment>>, TError, {data: CreateConduitDeploymentDto}, TContext>(mutationFn, mutationOptions)
    }
    
export const bridgeControllerGetConduitDeployment = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ConduitDeploymentConfigDto>> => {
    return axios.get(
      `/api/bridge/conduit/deployment/${id}`,options
    );
  }


export const getBridgeControllerGetConduitDeploymentQueryKey = (id: string,) => [`/api/bridge/conduit/deployment/${id}`];

    
export type BridgeControllerGetConduitDeploymentQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>>
export type BridgeControllerGetConduitDeploymentQueryError = AxiosError<unknown>

export const useBridgeControllerGetConduitDeployment = <TData = Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBridgeControllerGetConduitDeploymentQueryKey(id);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>> = ({ signal }) => bridgeControllerGetConduitDeployment(id, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>, TError, TData>(queryKey, queryFn, {enabled: !!(id), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


export const bridgeControllerTrack = (
    actionDto: ActionDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axios.post(
      `/api/bridge/track`,
      actionDto,options
    );
  }



    export type BridgeControllerTrackMutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerTrack>>>
    export type BridgeControllerTrackMutationBody = ActionDto
    export type BridgeControllerTrackMutationError = AxiosError<unknown>

    export const useBridgeControllerTrack = <TError = AxiosError<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerTrack>>, TError,{data: ActionDto}, TContext>, axios?: AxiosRequestConfig}
) => {
      const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerTrack>>, {data: ActionDto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerTrack(data,axiosOptions)
        }

      return useMutation<Awaited<ReturnType<typeof bridgeControllerTrack>>, TError, {data: ActionDto}, TContext>(mutationFn, mutationOptions)
    }
    
export const bridgeControllerGetNfts = (
    deploymentId: string,
    withdrawing: string,
    address: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BridgeNftDto[]>> => {
    return axios.get(
      `/api/bridge/nfts/${deploymentId}/${withdrawing}/${address}`,options
    );
  }


export const getBridgeControllerGetNftsQueryKey = (deploymentId: string,
    withdrawing: string,
    address: string,) => [`/api/bridge/nfts/${deploymentId}/${withdrawing}/${address}`];

    
export type BridgeControllerGetNftsQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetNfts>>>
export type BridgeControllerGetNftsQueryError = AxiosError<unknown>

export const useBridgeControllerGetNfts = <TData = Awaited<ReturnType<typeof bridgeControllerGetNfts>>, TError = AxiosError<unknown>>(
 deploymentId: string,
    withdrawing: string,
    address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetNfts>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBridgeControllerGetNftsQueryKey(deploymentId,withdrawing,address);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetNfts>>> = ({ signal }) => bridgeControllerGetNfts(deploymentId,withdrawing,address, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof bridgeControllerGetNfts>>, TError, TData>(queryKey, queryFn, {enabled: !!(deploymentId && withdrawing && address), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


export const bridgeControllerGetTrmFlaggedStatus = (
    address: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BoolDto>> => {
    return axios.get(
      `/api/bridge/trm_flagged_status/${address}`,options
    );
  }


export const getBridgeControllerGetTrmFlaggedStatusQueryKey = (address: string,) => [`/api/bridge/trm_flagged_status/${address}`];

    
export type BridgeControllerGetTrmFlaggedStatusQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetTrmFlaggedStatus>>>
export type BridgeControllerGetTrmFlaggedStatusQueryError = AxiosError<unknown>

export const useBridgeControllerGetTrmFlaggedStatus = <TData = Awaited<ReturnType<typeof bridgeControllerGetTrmFlaggedStatus>>, TError = AxiosError<unknown>>(
 address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetTrmFlaggedStatus>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBridgeControllerGetTrmFlaggedStatusQueryKey(address);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetTrmFlaggedStatus>>> = ({ signal }) => bridgeControllerGetTrmFlaggedStatus(address, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof bridgeControllerGetTrmFlaggedStatus>>, TError, TData>(queryKey, queryFn, {enabled: !!(address), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


export const bridgeControllerGetStatus = (
    address: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BoolDto>> => {
    return axios.get(
      `/api/bridge/status/${address}`,options
    );
  }


export const getBridgeControllerGetStatusQueryKey = (address: string,) => [`/api/bridge/status/${address}`];

    
export type BridgeControllerGetStatusQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetStatus>>>
export type BridgeControllerGetStatusQueryError = AxiosError<unknown>

export const useBridgeControllerGetStatus = <TData = Awaited<ReturnType<typeof bridgeControllerGetStatus>>, TError = AxiosError<unknown>>(
 address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetStatus>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBridgeControllerGetStatusQueryKey(address);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetStatus>>> = ({ signal }) => bridgeControllerGetStatus(address, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof bridgeControllerGetStatus>>, TError, TData>(queryKey, queryFn, {enabled: !!(address), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


