/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * API
 * API docs
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import type {
  AcrossAvailableRouteDto,
  AcrossDomainDto,
  ActivityDto,
  ActivityV3Dto,
  BoolDto,
  BridgeConfigDto,
  BridgeControllerGetActivityParams,
  BridgeControllerGetDeploymentsParams,
  BridgeControllerGetRoutesParams,
  BridgeControllerGetTokens200Item,
  CctpDomainDto,
  ConduitDeploymentConfigDto,
  CreateConduitDeploymentDto,
  DeploymentDto,
  DeploymentsQueryDto,
  FiatPricesDto,
  GetActivityDto,
  GetActivityV3Dto,
  GetActivityV4Dto,
  HyperlaneCustomWarpRouteFileRequestDto,
  HyperlaneCustomWarpRouteFileResponseDto,
  HyperlaneMailboxDto,
  IdDto,
  NumberDto,
  PricesDto,
  RouteRequestDto,
  RouteResponseDto,
  SuperbridgeConfigDto,
  SyncStatusDto,
  TransactionDto
} from './model'




export const bridgeControllerGetActivity = (
    address: string,
    params: BridgeControllerGetActivityParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ActivityDto>> => {
    
    return axios.get(
      `/api/bridge/activity/${address}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getBridgeControllerGetActivityQueryKey = (address: string,
    params: BridgeControllerGetActivityParams,) => {
    return [`/api/bridge/activity/${address}`, ...(params ? [params]: [])] as const;
    }

    
export const getBridgeControllerGetActivityQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetActivity>>, TError = AxiosError<unknown>>(address: string,
    params: BridgeControllerGetActivityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetActivity>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetActivityQueryKey(address,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetActivity>>> = ({ signal }) => bridgeControllerGetActivity(address,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetActivity>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetActivityQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetActivity>>>
export type BridgeControllerGetActivityQueryError = AxiosError<unknown>

export const useBridgeControllerGetActivity = <TData = Awaited<ReturnType<typeof bridgeControllerGetActivity>>, TError = AxiosError<unknown>>(
 address: string,
    params: BridgeControllerGetActivityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetActivity>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetActivityQueryOptions(address,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerGetActivityV2 = (
    getActivityDto: GetActivityDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ActivityDto>> => {
    
    return axios.post(
      `/api/bridge/activity`,
      getActivityDto,options
    );
  }



export const getBridgeControllerGetActivityV2MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetActivityV2>>, TError,{data: GetActivityDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetActivityV2>>, TError,{data: GetActivityDto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetActivityV2>>, {data: GetActivityDto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerGetActivityV2(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BridgeControllerGetActivityV2MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetActivityV2>>>
    export type BridgeControllerGetActivityV2MutationBody = GetActivityDto
    export type BridgeControllerGetActivityV2MutationError = AxiosError<unknown>

    export const useBridgeControllerGetActivityV2 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetActivityV2>>, TError,{data: GetActivityDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof bridgeControllerGetActivityV2>>,
        TError,
        {data: GetActivityDto},
        TContext
      > => {

      const mutationOptions = getBridgeControllerGetActivityV2MutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const bridgeControllerGetActivityV3 = (
    getActivityV3Dto: GetActivityV3Dto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ActivityV3Dto>> => {
    
    return axios.post(
      `/api/v3/bridge/activity`,
      getActivityV3Dto,options
    );
  }



export const getBridgeControllerGetActivityV3MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetActivityV3>>, TError,{data: GetActivityV3Dto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetActivityV3>>, TError,{data: GetActivityV3Dto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetActivityV3>>, {data: GetActivityV3Dto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerGetActivityV3(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BridgeControllerGetActivityV3MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetActivityV3>>>
    export type BridgeControllerGetActivityV3MutationBody = GetActivityV3Dto
    export type BridgeControllerGetActivityV3MutationError = AxiosError<unknown>

    export const useBridgeControllerGetActivityV3 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetActivityV3>>, TError,{data: GetActivityV3Dto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof bridgeControllerGetActivityV3>>,
        TError,
        {data: GetActivityV3Dto},
        TContext
      > => {

      const mutationOptions = getBridgeControllerGetActivityV3MutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const bridgeControllerGetActivityV4 = (
    getActivityV4Dto: GetActivityV4Dto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ActivityV3Dto>> => {
    
    return axios.post(
      `/api/v4/bridge/activity`,
      getActivityV4Dto,options
    );
  }



export const getBridgeControllerGetActivityV4MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetActivityV4>>, TError,{data: GetActivityV4Dto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetActivityV4>>, TError,{data: GetActivityV4Dto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetActivityV4>>, {data: GetActivityV4Dto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerGetActivityV4(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BridgeControllerGetActivityV4MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetActivityV4>>>
    export type BridgeControllerGetActivityV4MutationBody = GetActivityV4Dto
    export type BridgeControllerGetActivityV4MutationError = AxiosError<unknown>

    export const useBridgeControllerGetActivityV4 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetActivityV4>>, TError,{data: GetActivityV4Dto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof bridgeControllerGetActivityV4>>,
        TError,
        {data: GetActivityV4Dto},
        TContext
      > => {

      const mutationOptions = getBridgeControllerGetActivityV4MutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const bridgeControllerGetProveTransaction = (
    idDto: IdDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionDto>> => {
    
    return axios.post(
      `/api/bridge/op_prove`,
      idDto,options
    );
  }



export const getBridgeControllerGetProveTransactionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetProveTransaction>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetProveTransaction>>, TError,{data: IdDto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetProveTransaction>>, {data: IdDto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerGetProveTransaction(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BridgeControllerGetProveTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetProveTransaction>>>
    export type BridgeControllerGetProveTransactionMutationBody = IdDto
    export type BridgeControllerGetProveTransactionMutationError = AxiosError<unknown>

    export const useBridgeControllerGetProveTransaction = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetProveTransaction>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof bridgeControllerGetProveTransaction>>,
        TError,
        {data: IdDto},
        TContext
      > => {

      const mutationOptions = getBridgeControllerGetProveTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const bridgeControllerGetFinaliseTransaction = (
    idDto: IdDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionDto>> => {
    
    return axios.post(
      `/api/bridge/op_finalise`,
      idDto,options
    );
  }



export const getBridgeControllerGetFinaliseTransactionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransaction>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransaction>>, TError,{data: IdDto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransaction>>, {data: IdDto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerGetFinaliseTransaction(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BridgeControllerGetFinaliseTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransaction>>>
    export type BridgeControllerGetFinaliseTransactionMutationBody = IdDto
    export type BridgeControllerGetFinaliseTransactionMutationError = AxiosError<unknown>

    export const useBridgeControllerGetFinaliseTransaction = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransaction>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof bridgeControllerGetFinaliseTransaction>>,
        TError,
        {data: IdDto},
        TContext
      > => {

      const mutationOptions = getBridgeControllerGetFinaliseTransactionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const bridgeControllerGetArbitrumFinaliseTransactionV2 = (
    idDto: IdDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionDto>> => {
    
    return axios.post(
      `/api/bridge/arb_finalise`,
      idDto,options
    );
  }



export const getBridgeControllerGetArbitrumFinaliseTransactionV2MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransactionV2>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransactionV2>>, TError,{data: IdDto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransactionV2>>, {data: IdDto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerGetArbitrumFinaliseTransactionV2(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BridgeControllerGetArbitrumFinaliseTransactionV2MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransactionV2>>>
    export type BridgeControllerGetArbitrumFinaliseTransactionV2MutationBody = IdDto
    export type BridgeControllerGetArbitrumFinaliseTransactionV2MutationError = AxiosError<unknown>

    export const useBridgeControllerGetArbitrumFinaliseTransactionV2 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransactionV2>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof bridgeControllerGetArbitrumFinaliseTransactionV2>>,
        TError,
        {data: IdDto},
        TContext
      > => {

      const mutationOptions = getBridgeControllerGetArbitrumFinaliseTransactionV2MutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const bridgeControllerGetCctpMintTransactionV2 = (
    idDto: IdDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionDto>> => {
    
    return axios.post(
      `/api/bridge/cctp_mint`,
      idDto,options
    );
  }



export const getBridgeControllerGetCctpMintTransactionV2MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransactionV2>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransactionV2>>, TError,{data: IdDto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransactionV2>>, {data: IdDto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerGetCctpMintTransactionV2(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BridgeControllerGetCctpMintTransactionV2MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransactionV2>>>
    export type BridgeControllerGetCctpMintTransactionV2MutationBody = IdDto
    export type BridgeControllerGetCctpMintTransactionV2MutationError = AxiosError<unknown>

    export const useBridgeControllerGetCctpMintTransactionV2 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransactionV2>>, TError,{data: IdDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof bridgeControllerGetCctpMintTransactionV2>>,
        TError,
        {data: IdDto},
        TContext
      > => {

      const mutationOptions = getBridgeControllerGetCctpMintTransactionV2MutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const bridgeControllerFiatPrices = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FiatPricesDto>> => {
    
    return axios.get(
      `/api/bridge/fiat_prices`,options
    );
  }


export const getBridgeControllerFiatPricesQueryKey = () => {
    return [`/api/bridge/fiat_prices`] as const;
    }

    
export const getBridgeControllerFiatPricesQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerFiatPrices>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerFiatPrices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerFiatPricesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerFiatPrices>>> = ({ signal }) => bridgeControllerFiatPrices({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerFiatPrices>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerFiatPricesQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerFiatPrices>>>
export type BridgeControllerFiatPricesQueryError = AxiosError<unknown>

export const useBridgeControllerFiatPrices = <TData = Awaited<ReturnType<typeof bridgeControllerFiatPrices>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerFiatPrices>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerFiatPricesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerGetTokenPrices = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PricesDto>> => {
    
    return axios.get(
      `/api/bridge/token_prices`,options
    );
  }


export const getBridgeControllerGetTokenPricesQueryKey = () => {
    return [`/api/bridge/token_prices`] as const;
    }

    
export const getBridgeControllerGetTokenPricesQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetTokenPricesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>> = ({ signal }) => bridgeControllerGetTokenPrices({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetTokenPricesQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>>
export type BridgeControllerGetTokenPricesQueryError = AxiosError<unknown>

export const useBridgeControllerGetTokenPrices = <TData = Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetTokenPrices>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetTokenPricesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerGetDeployments = (
    params?: BridgeControllerGetDeploymentsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DeploymentDto[]>> => {
    
    return axios.get(
      `/api/bridge/deployments`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getBridgeControllerGetDeploymentsQueryKey = (params?: BridgeControllerGetDeploymentsParams,) => {
    return [`/api/bridge/deployments`, ...(params ? [params]: [])] as const;
    }

    
export const getBridgeControllerGetDeploymentsQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetDeployments>>, TError = AxiosError<unknown>>(params?: BridgeControllerGetDeploymentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeployments>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetDeploymentsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetDeployments>>> = ({ signal }) => bridgeControllerGetDeployments(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeployments>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetDeploymentsQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetDeployments>>>
export type BridgeControllerGetDeploymentsQueryError = AxiosError<unknown>

export const useBridgeControllerGetDeployments = <TData = Awaited<ReturnType<typeof bridgeControllerGetDeployments>>, TError = AxiosError<unknown>>(
 params?: BridgeControllerGetDeploymentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeployments>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetDeploymentsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerGetDeploymentsV2 = (
    deploymentsQueryDto: DeploymentsQueryDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DeploymentDto[]>> => {
    
    return axios.post(
      `/api/bridge/deployments`,
      deploymentsQueryDto,options
    );
  }



export const getBridgeControllerGetDeploymentsV2MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsV2>>, TError,{data: DeploymentsQueryDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsV2>>, TError,{data: DeploymentsQueryDto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsV2>>, {data: DeploymentsQueryDto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerGetDeploymentsV2(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BridgeControllerGetDeploymentsV2MutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsV2>>>
    export type BridgeControllerGetDeploymentsV2MutationBody = DeploymentsQueryDto
    export type BridgeControllerGetDeploymentsV2MutationError = AxiosError<unknown>

    export const useBridgeControllerGetDeploymentsV2 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsV2>>, TError,{data: DeploymentsQueryDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof bridgeControllerGetDeploymentsV2>>,
        TError,
        {data: DeploymentsQueryDto},
        TContext
      > => {

      const mutationOptions = getBridgeControllerGetDeploymentsV2MutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const bridgeControllerGetDeploymentsByDomain = (
    domain: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DeploymentDto[]>> => {
    
    return axios.get(
      `/api/bridge/deployments_by_domain/${domain}`,options
    );
  }


export const getBridgeControllerGetDeploymentsByDomainQueryKey = (domain: string,) => {
    return [`/api/bridge/deployments_by_domain/${domain}`] as const;
    }

    
export const getBridgeControllerGetDeploymentsByDomainQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>, TError = AxiosError<unknown>>(domain: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetDeploymentsByDomainQueryKey(domain);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>> = ({ signal }) => bridgeControllerGetDeploymentsByDomain(domain, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(domain), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetDeploymentsByDomainQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>>
export type BridgeControllerGetDeploymentsByDomainQueryError = AxiosError<unknown>

export const useBridgeControllerGetDeploymentsByDomain = <TData = Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>, TError = AxiosError<unknown>>(
 domain: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentsByDomain>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetDeploymentsByDomainQueryOptions(domain,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerGetCctpDomains = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CctpDomainDto[]>> => {
    
    return axios.get(
      `/api/bridge/cctp_domains`,options
    );
  }


export const getBridgeControllerGetCctpDomainsQueryKey = () => {
    return [`/api/bridge/cctp_domains`] as const;
    }

    
export const getBridgeControllerGetCctpDomainsQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetCctpDomainsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>> = ({ signal }) => bridgeControllerGetCctpDomains({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetCctpDomainsQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>>
export type BridgeControllerGetCctpDomainsQueryError = AxiosError<unknown>

export const useBridgeControllerGetCctpDomains = <TData = Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetCctpDomains>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetCctpDomainsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerGetAcrossDomains = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AcrossDomainDto[]>> => {
    
    return axios.get(
      `/api/bridge/across_domains`,options
    );
  }


export const getBridgeControllerGetAcrossDomainsQueryKey = () => {
    return [`/api/bridge/across_domains`] as const;
    }

    
export const getBridgeControllerGetAcrossDomainsQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetAcrossDomains>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetAcrossDomains>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetAcrossDomainsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetAcrossDomains>>> = ({ signal }) => bridgeControllerGetAcrossDomains({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetAcrossDomains>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetAcrossDomainsQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetAcrossDomains>>>
export type BridgeControllerGetAcrossDomainsQueryError = AxiosError<unknown>

export const useBridgeControllerGetAcrossDomains = <TData = Awaited<ReturnType<typeof bridgeControllerGetAcrossDomains>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetAcrossDomains>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetAcrossDomainsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerGetHyperlaneMailboxes = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<HyperlaneMailboxDto[]>> => {
    
    return axios.get(
      `/api/bridge/hyperlane_mailboxes`,options
    );
  }


export const getBridgeControllerGetHyperlaneMailboxesQueryKey = () => {
    return [`/api/bridge/hyperlane_mailboxes`] as const;
    }

    
export const getBridgeControllerGetHyperlaneMailboxesQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetHyperlaneMailboxes>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetHyperlaneMailboxes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetHyperlaneMailboxesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetHyperlaneMailboxes>>> = ({ signal }) => bridgeControllerGetHyperlaneMailboxes({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetHyperlaneMailboxes>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetHyperlaneMailboxesQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetHyperlaneMailboxes>>>
export type BridgeControllerGetHyperlaneMailboxesQueryError = AxiosError<unknown>

export const useBridgeControllerGetHyperlaneMailboxes = <TData = Awaited<ReturnType<typeof bridgeControllerGetHyperlaneMailboxes>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetHyperlaneMailboxes>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetHyperlaneMailboxesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerGetAcrossAvailableRoutes = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AcrossAvailableRouteDto[]>> => {
    
    return axios.get(
      `/api/bridge/across_available_routes`,options
    );
  }


export const getBridgeControllerGetAcrossAvailableRoutesQueryKey = () => {
    return [`/api/bridge/across_available_routes`] as const;
    }

    
export const getBridgeControllerGetAcrossAvailableRoutesQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetAcrossAvailableRoutes>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetAcrossAvailableRoutes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetAcrossAvailableRoutesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetAcrossAvailableRoutes>>> = ({ signal }) => bridgeControllerGetAcrossAvailableRoutes({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetAcrossAvailableRoutes>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetAcrossAvailableRoutesQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetAcrossAvailableRoutes>>>
export type BridgeControllerGetAcrossAvailableRoutesQueryError = AxiosError<unknown>

export const useBridgeControllerGetAcrossAvailableRoutes = <TData = Awaited<ReturnType<typeof bridgeControllerGetAcrossAvailableRoutes>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetAcrossAvailableRoutes>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetAcrossAvailableRoutesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerCreateConduitDeployment = (
    createConduitDeploymentDto: CreateConduitDeploymentDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ConduitDeploymentConfigDto>> => {
    
    return axios.post(
      `/api/bridge/conduit/deployment`,
      createConduitDeploymentDto,options
    );
  }



export const getBridgeControllerCreateConduitDeploymentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerCreateConduitDeployment>>, TError,{data: CreateConduitDeploymentDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerCreateConduitDeployment>>, TError,{data: CreateConduitDeploymentDto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerCreateConduitDeployment>>, {data: CreateConduitDeploymentDto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerCreateConduitDeployment(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BridgeControllerCreateConduitDeploymentMutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerCreateConduitDeployment>>>
    export type BridgeControllerCreateConduitDeploymentMutationBody = CreateConduitDeploymentDto
    export type BridgeControllerCreateConduitDeploymentMutationError = AxiosError<unknown>

    export const useBridgeControllerCreateConduitDeployment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerCreateConduitDeployment>>, TError,{data: CreateConduitDeploymentDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof bridgeControllerCreateConduitDeployment>>,
        TError,
        {data: CreateConduitDeploymentDto},
        TContext
      > => {

      const mutationOptions = getBridgeControllerCreateConduitDeploymentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const bridgeControllerGetConduitDeployment = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ConduitDeploymentConfigDto>> => {
    
    return axios.get(
      `/api/bridge/conduit/deployment/${id}`,options
    );
  }


export const getBridgeControllerGetConduitDeploymentQueryKey = (id: string,) => {
    return [`/api/bridge/conduit/deployment/${id}`] as const;
    }

    
export const getBridgeControllerGetConduitDeploymentQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetConduitDeploymentQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>> = ({ signal }) => bridgeControllerGetConduitDeployment(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetConduitDeploymentQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>>
export type BridgeControllerGetConduitDeploymentQueryError = AxiosError<unknown>

export const useBridgeControllerGetConduitDeployment = <TData = Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetConduitDeployment>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetConduitDeploymentQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerGetStatus = (
    address: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BoolDto>> => {
    
    return axios.get(
      `/api/bridge/status/${address}`,options
    );
  }


export const getBridgeControllerGetStatusQueryKey = (address: string,) => {
    return [`/api/bridge/status/${address}`] as const;
    }

    
export const getBridgeControllerGetStatusQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetStatus>>, TError = AxiosError<unknown>>(address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetStatusQueryKey(address);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetStatus>>> = ({ signal }) => bridgeControllerGetStatus(address, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetStatusQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetStatus>>>
export type BridgeControllerGetStatusQueryError = AxiosError<unknown>

export const useBridgeControllerGetStatus = <TData = Awaited<ReturnType<typeof bridgeControllerGetStatus>>, TError = AxiosError<unknown>>(
 address: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetStatus>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetStatusQueryOptions(address,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerGetLatestStateRoot = (
    deploymentId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<NumberDto>> => {
    
    return axios.get(
      `/api/bridge/latest_state_root/${deploymentId}`,options
    );
  }


export const getBridgeControllerGetLatestStateRootQueryKey = (deploymentId: string,) => {
    return [`/api/bridge/latest_state_root/${deploymentId}`] as const;
    }

    
export const getBridgeControllerGetLatestStateRootQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetLatestStateRoot>>, TError = AxiosError<unknown>>(deploymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetLatestStateRoot>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetLatestStateRootQueryKey(deploymentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetLatestStateRoot>>> = ({ signal }) => bridgeControllerGetLatestStateRoot(deploymentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(deploymentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetLatestStateRoot>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetLatestStateRootQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetLatestStateRoot>>>
export type BridgeControllerGetLatestStateRootQueryError = AxiosError<unknown>

export const useBridgeControllerGetLatestStateRoot = <TData = Awaited<ReturnType<typeof bridgeControllerGetLatestStateRoot>>, TError = AxiosError<unknown>>(
 deploymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetLatestStateRoot>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetLatestStateRootQueryOptions(deploymentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerGetLatestDisputeGame = (
    deploymentId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<NumberDto>> => {
    
    return axios.get(
      `/api/bridge/latest_dispute_game/${deploymentId}`,options
    );
  }


export const getBridgeControllerGetLatestDisputeGameQueryKey = (deploymentId: string,) => {
    return [`/api/bridge/latest_dispute_game/${deploymentId}`] as const;
    }

    
export const getBridgeControllerGetLatestDisputeGameQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetLatestDisputeGame>>, TError = AxiosError<unknown>>(deploymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetLatestDisputeGame>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetLatestDisputeGameQueryKey(deploymentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetLatestDisputeGame>>> = ({ signal }) => bridgeControllerGetLatestDisputeGame(deploymentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(deploymentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetLatestDisputeGame>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetLatestDisputeGameQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetLatestDisputeGame>>>
export type BridgeControllerGetLatestDisputeGameQueryError = AxiosError<unknown>

export const useBridgeControllerGetLatestDisputeGame = <TData = Awaited<ReturnType<typeof bridgeControllerGetLatestDisputeGame>>, TError = AxiosError<unknown>>(
 deploymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetLatestDisputeGame>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetLatestDisputeGameQueryOptions(deploymentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerGetSuperbridgeConfig = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SuperbridgeConfigDto>> => {
    
    return axios.get(
      `/api/bridge/superbridge_config`,options
    );
  }


export const getBridgeControllerGetSuperbridgeConfigQueryKey = () => {
    return [`/api/bridge/superbridge_config`] as const;
    }

    
export const getBridgeControllerGetSuperbridgeConfigQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetSuperbridgeConfig>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetSuperbridgeConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetSuperbridgeConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetSuperbridgeConfig>>> = ({ signal }) => bridgeControllerGetSuperbridgeConfig({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetSuperbridgeConfig>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetSuperbridgeConfigQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetSuperbridgeConfig>>>
export type BridgeControllerGetSuperbridgeConfigQueryError = AxiosError<unknown>

export const useBridgeControllerGetSuperbridgeConfig = <TData = Awaited<ReturnType<typeof bridgeControllerGetSuperbridgeConfig>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetSuperbridgeConfig>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetSuperbridgeConfigQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerGetRoutes = (
    params: BridgeControllerGetRoutesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RouteResponseDto>> => {
    
    return axios.get(
      `/api/bridge/routes`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getBridgeControllerGetRoutesQueryKey = (params: BridgeControllerGetRoutesParams,) => {
    return [`/api/bridge/routes`, ...(params ? [params]: [])] as const;
    }

    
export const getBridgeControllerGetRoutesQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetRoutes>>, TError = AxiosError<unknown>>(params: BridgeControllerGetRoutesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetRoutes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetRoutesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetRoutes>>> = ({ signal }) => bridgeControllerGetRoutes(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetRoutes>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetRoutesQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetRoutes>>>
export type BridgeControllerGetRoutesQueryError = AxiosError<unknown>

export const useBridgeControllerGetRoutes = <TData = Awaited<ReturnType<typeof bridgeControllerGetRoutes>>, TError = AxiosError<unknown>>(
 params: BridgeControllerGetRoutesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetRoutes>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetRoutesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerGetBridgeRoutes = (
    routeRequestDto: RouteRequestDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RouteResponseDto>> => {
    
    return axios.post(
      `/api/bridge/routes`,
      routeRequestDto,options
    );
  }



export const getBridgeControllerGetBridgeRoutesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeRoutes>>, TError,{data: RouteRequestDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeRoutes>>, TError,{data: RouteRequestDto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bridgeControllerGetBridgeRoutes>>, {data: RouteRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  bridgeControllerGetBridgeRoutes(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BridgeControllerGetBridgeRoutesMutationResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetBridgeRoutes>>>
    export type BridgeControllerGetBridgeRoutesMutationBody = RouteRequestDto
    export type BridgeControllerGetBridgeRoutesMutationError = AxiosError<unknown>

    export const useBridgeControllerGetBridgeRoutes = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeRoutes>>, TError,{data: RouteRequestDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof bridgeControllerGetBridgeRoutes>>,
        TError,
        {data: RouteRequestDto},
        TContext
      > => {

      const mutationOptions = getBridgeControllerGetBridgeRoutesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const bridgeControllerGetTokens = (
    domain: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BridgeControllerGetTokens200Item[]>> => {
    
    return axios.get(
      `/api/bridge/tokens/${domain}`,options
    );
  }


export const getBridgeControllerGetTokensQueryKey = (domain: string,) => {
    return [`/api/bridge/tokens/${domain}`] as const;
    }

    
export const getBridgeControllerGetTokensQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetTokens>>, TError = AxiosError<unknown>>(domain: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetTokens>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetTokensQueryKey(domain);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetTokens>>> = ({ signal }) => bridgeControllerGetTokens(domain, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(domain), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetTokens>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetTokensQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetTokens>>>
export type BridgeControllerGetTokensQueryError = AxiosError<unknown>

export const useBridgeControllerGetTokens = <TData = Awaited<ReturnType<typeof bridgeControllerGetTokens>>, TError = AxiosError<unknown>>(
 domain: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetTokens>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetTokensQueryOptions(domain,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerGetBridgeConfigByDomain = (
    domain: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BridgeConfigDto>> => {
    
    return axios.get(
      `/api/bridge/bridge_config/${domain}`,options
    );
  }


export const getBridgeControllerGetBridgeConfigByDomainQueryKey = (domain: string,) => {
    return [`/api/bridge/bridge_config/${domain}`] as const;
    }

    
export const getBridgeControllerGetBridgeConfigByDomainQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomain>>, TError = AxiosError<unknown>>(domain: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomain>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetBridgeConfigByDomainQueryKey(domain);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomain>>> = ({ signal }) => bridgeControllerGetBridgeConfigByDomain(domain, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(domain), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomain>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetBridgeConfigByDomainQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomain>>>
export type BridgeControllerGetBridgeConfigByDomainQueryError = AxiosError<unknown>

export const useBridgeControllerGetBridgeConfigByDomain = <TData = Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomain>>, TError = AxiosError<unknown>>(
 domain: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomain>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetBridgeConfigByDomainQueryOptions(domain,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerGetBridgeConfigByDomainV2 = (
    domain: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BridgeConfigDto>> => {
    
    return axios.get(
      `/api/v2/bridge/bridge_config/${domain}`,options
    );
  }


export const getBridgeControllerGetBridgeConfigByDomainV2QueryKey = (domain: string,) => {
    return [`/api/v2/bridge/bridge_config/${domain}`] as const;
    }

    
export const getBridgeControllerGetBridgeConfigByDomainV2QueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV2>>, TError = AxiosError<unknown>>(domain: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV2>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetBridgeConfigByDomainV2QueryKey(domain);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV2>>> = ({ signal }) => bridgeControllerGetBridgeConfigByDomainV2(domain, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(domain), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV2>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetBridgeConfigByDomainV2QueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV2>>>
export type BridgeControllerGetBridgeConfigByDomainV2QueryError = AxiosError<unknown>

export const useBridgeControllerGetBridgeConfigByDomainV2 = <TData = Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV2>>, TError = AxiosError<unknown>>(
 domain: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetBridgeConfigByDomainV2>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetBridgeConfigByDomainV2QueryOptions(domain,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const bridgeControllerGetDeploymentSyncStatus = (
    deploymentId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SyncStatusDto[]>> => {
    
    return axios.get(
      `/api/bridge/sync_status/${deploymentId}`,options
    );
  }


export const getBridgeControllerGetDeploymentSyncStatusQueryKey = (deploymentId: string,) => {
    return [`/api/bridge/sync_status/${deploymentId}`] as const;
    }

    
export const getBridgeControllerGetDeploymentSyncStatusQueryOptions = <TData = Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>, TError = AxiosError<unknown>>(deploymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBridgeControllerGetDeploymentSyncStatusQueryKey(deploymentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>> = ({ signal }) => bridgeControllerGetDeploymentSyncStatus(deploymentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(deploymentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type BridgeControllerGetDeploymentSyncStatusQueryResult = NonNullable<Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>>
export type BridgeControllerGetDeploymentSyncStatusQueryError = AxiosError<unknown>

export const useBridgeControllerGetDeploymentSyncStatus = <TData = Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>, TError = AxiosError<unknown>>(
 deploymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bridgeControllerGetDeploymentSyncStatus>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBridgeControllerGetDeploymentSyncStatusQueryOptions(deploymentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const hyperlaneControllerResolveWarpRouteYamlFile = (
    hyperlaneCustomWarpRouteFileRequestDto: HyperlaneCustomWarpRouteFileRequestDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<HyperlaneCustomWarpRouteFileResponseDto>> => {
    
    return axios.post(
      `/api/hyperlane/resolve_warp_route_yaml_file`,
      hyperlaneCustomWarpRouteFileRequestDto,options
    );
  }



export const getHyperlaneControllerResolveWarpRouteYamlFileMutationOptions = <TError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof hyperlaneControllerResolveWarpRouteYamlFile>>, TError,{data: HyperlaneCustomWarpRouteFileRequestDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof hyperlaneControllerResolveWarpRouteYamlFile>>, TError,{data: HyperlaneCustomWarpRouteFileRequestDto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof hyperlaneControllerResolveWarpRouteYamlFile>>, {data: HyperlaneCustomWarpRouteFileRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  hyperlaneControllerResolveWarpRouteYamlFile(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type HyperlaneControllerResolveWarpRouteYamlFileMutationResult = NonNullable<Awaited<ReturnType<typeof hyperlaneControllerResolveWarpRouteYamlFile>>>
    export type HyperlaneControllerResolveWarpRouteYamlFileMutationBody = HyperlaneCustomWarpRouteFileRequestDto
    export type HyperlaneControllerResolveWarpRouteYamlFileMutationError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>

    export const useHyperlaneControllerResolveWarpRouteYamlFile = <TError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof hyperlaneControllerResolveWarpRouteYamlFile>>, TError,{data: HyperlaneCustomWarpRouteFileRequestDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof hyperlaneControllerResolveWarpRouteYamlFile>>,
        TError,
        {data: HyperlaneCustomWarpRouteFileRequestDto},
        TContext
      > => {

      const mutationOptions = getHyperlaneControllerResolveWarpRouteYamlFileMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const hyperlaneControllerSaveWarpRouteYamlFile = (
    hyperlaneCustomWarpRouteFileRequestDto: HyperlaneCustomWarpRouteFileRequestDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<IdDto>> => {
    
    return axios.post(
      `/api/hyperlane/custom_routes`,
      hyperlaneCustomWarpRouteFileRequestDto,options
    );
  }



export const getHyperlaneControllerSaveWarpRouteYamlFileMutationOptions = <TError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof hyperlaneControllerSaveWarpRouteYamlFile>>, TError,{data: HyperlaneCustomWarpRouteFileRequestDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof hyperlaneControllerSaveWarpRouteYamlFile>>, TError,{data: HyperlaneCustomWarpRouteFileRequestDto}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof hyperlaneControllerSaveWarpRouteYamlFile>>, {data: HyperlaneCustomWarpRouteFileRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  hyperlaneControllerSaveWarpRouteYamlFile(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type HyperlaneControllerSaveWarpRouteYamlFileMutationResult = NonNullable<Awaited<ReturnType<typeof hyperlaneControllerSaveWarpRouteYamlFile>>>
    export type HyperlaneControllerSaveWarpRouteYamlFileMutationBody = HyperlaneCustomWarpRouteFileRequestDto
    export type HyperlaneControllerSaveWarpRouteYamlFileMutationError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>

    export const useHyperlaneControllerSaveWarpRouteYamlFile = <TError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof hyperlaneControllerSaveWarpRouteYamlFile>>, TError,{data: HyperlaneCustomWarpRouteFileRequestDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof hyperlaneControllerSaveWarpRouteYamlFile>>,
        TError,
        {data: HyperlaneCustomWarpRouteFileRequestDto},
        TContext
      > => {

      const mutationOptions = getHyperlaneControllerSaveWarpRouteYamlFileMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const hyperlaneControllerGetWarpRouteYamlFile = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<HyperlaneCustomWarpRouteFileResponseDto>> => {
    
    return axios.get(
      `/api/hyperlane/custom_routes/${id}`,options
    );
  }


export const getHyperlaneControllerGetWarpRouteYamlFileQueryKey = (id: string,) => {
    return [`/api/hyperlane/custom_routes/${id}`] as const;
    }

    
export const getHyperlaneControllerGetWarpRouteYamlFileQueryOptions = <TData = Awaited<ReturnType<typeof hyperlaneControllerGetWarpRouteYamlFile>>, TError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof hyperlaneControllerGetWarpRouteYamlFile>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHyperlaneControllerGetWarpRouteYamlFileQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof hyperlaneControllerGetWarpRouteYamlFile>>> = ({ signal }) => hyperlaneControllerGetWarpRouteYamlFile(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof hyperlaneControllerGetWarpRouteYamlFile>>, TError, TData> & { queryKey: QueryKey }
}

export type HyperlaneControllerGetWarpRouteYamlFileQueryResult = NonNullable<Awaited<ReturnType<typeof hyperlaneControllerGetWarpRouteYamlFile>>>
export type HyperlaneControllerGetWarpRouteYamlFileQueryError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>

export const useHyperlaneControllerGetWarpRouteYamlFile = <TData = Awaited<ReturnType<typeof hyperlaneControllerGetWarpRouteYamlFile>>, TError = AxiosError<HyperlaneCustomWarpRouteFileResponseDto>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof hyperlaneControllerGetWarpRouteYamlFile>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getHyperlaneControllerGetWarpRouteYamlFileQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




